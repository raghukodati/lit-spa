// node_modules/lit-html/development/directives/private-async-helpers.js
var forAwaitOf = async (iterable, callback) => {
  for await (const v of iterable) {
    if (await callback(v) === false) {
      return;
    }
  }
};
var PseudoWeakRef = class {
  constructor(ref) {
    this._ref = ref;
  }
  /**
   * Disassociates the ref with the backing instance.
   */
  disconnect() {
    this._ref = void 0;
  }
  /**
   * Reassociates the ref with the backing instance.
   */
  reconnect(ref) {
    this._ref = ref;
  }
  /**
   * Retrieves the backing instance (will be undefined when disconnected)
   */
  deref() {
    return this._ref;
  }
};
var Pauser = class {
  constructor() {
    this._promise = void 0;
    this._resolve = void 0;
  }
  /**
   * When paused, returns a promise to be awaited; when unpaused, returns
   * undefined. Note that in the microtask between the pauser being resumed
   * an await of this promise resolving, the pauser could be paused again,
   * hence callers should check the promise in a loop when awaiting.
   * @returns A promise to be awaited when paused or undefined
   */
  get() {
    return this._promise;
  }
  /**
   * Creates a promise to be awaited
   */
  pause() {
    this._promise ?? (this._promise = new Promise((resolve) => this._resolve = resolve));
  }
  /**
   * Resolves the promise which may be awaited
   */
  resume() {
    var _a;
    (_a = this._resolve) == null ? void 0 : _a.call(this);
    this._promise = this._resolve = void 0;
  }
};

export {
  forAwaitOf,
  PseudoWeakRef,
  Pauser
};
/*! Bundled license information:

lit-html/development/directives/private-async-helpers.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=chunk-CBZSRIIO.js.map
