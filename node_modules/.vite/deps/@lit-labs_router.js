// node_modules/@lit-labs/router/development/routes.js
var patternCache = /* @__PURE__ */ new WeakMap();
var isPatternConfig = (route) => route.pattern !== void 0;
var getPattern = (route) => {
  if (isPatternConfig(route)) {
    return route.pattern;
  }
  let pattern = patternCache.get(route);
  if (pattern === void 0) {
    patternCache.set(route, pattern = new URLPattern({ pathname: route.path }));
  }
  return pattern;
};
var Routes = class {
  constructor(host, routes, options) {
    this.routes = [];
    this._childRoutes = [];
    this._currentParams = {};
    this._onRoutesConnected = (e) => {
      if (e.routes === this) {
        return;
      }
      const childRoutes = e.routes;
      this._childRoutes.push(childRoutes);
      childRoutes._parentRoutes = this;
      e.stopImmediatePropagation();
      e.onDisconnect = () => {
        var _a;
        (_a = this._childRoutes) == null ? void 0 : _a.splice(this._childRoutes.indexOf(childRoutes) >>> 0, 1);
      };
      const tailGroup = getTailGroup(this._currentParams);
      if (tailGroup !== void 0) {
        childRoutes.goto(tailGroup);
      }
    };
    (this._host = host).addController(this);
    this.routes = [...routes];
    this.fallback = options == null ? void 0 : options.fallback;
  }
  /**
   * Returns a URL string of the current route, including parent routes,
   * optionally replacing the local path with `pathname`.
   */
  link(pathname) {
    var _a;
    if (pathname == null ? void 0 : pathname.startsWith("/")) {
      return pathname;
    }
    if (pathname == null ? void 0 : pathname.startsWith(".")) {
      throw new Error("Not implemented");
    }
    pathname ?? (pathname = this._currentPathname);
    return (((_a = this._parentRoutes) == null ? void 0 : _a.link()) ?? "") + pathname;
  }
  /**
   * Navigates this routes controller to `pathname`.
   *
   * This does not navigate parent routes, so it isn't (yet) a general page
   * navigation API. It does navigate child routes if pathname matches a
   * pattern with a tail wildcard pattern (`/*`).
   */
  async goto(pathname) {
    let tailGroup;
    if (this.routes.length === 0 && this.fallback === void 0) {
      tailGroup = pathname;
      this._currentPathname = "";
      this._currentParams = { 0: tailGroup };
    } else {
      const route = this._getRoute(pathname);
      if (route === void 0) {
        throw new Error(`No route found for ${pathname}`);
      }
      const pattern = getPattern(route);
      const result = pattern.exec({ pathname });
      const params = (result == null ? void 0 : result.pathname.groups) ?? {};
      tailGroup = getTailGroup(params);
      if (typeof route.enter === "function") {
        const success = await route.enter(params);
        if (success === false) {
          return;
        }
      }
      this._currentRoute = route;
      this._currentParams = params;
      this._currentPathname = tailGroup === void 0 ? pathname : pathname.substring(0, pathname.length - tailGroup.length);
    }
    if (tailGroup !== void 0) {
      for (const childRoutes of this._childRoutes) {
        childRoutes.goto(tailGroup);
      }
    }
    this._host.requestUpdate();
  }
  /**
   * The result of calling the current route's render() callback.
   */
  outlet() {
    var _a, _b;
    return (_b = (_a = this._currentRoute) == null ? void 0 : _a.render) == null ? void 0 : _b.call(_a, this._currentParams);
  }
  /**
   * The current parsed route parameters.
   */
  get params() {
    return this._currentParams;
  }
  /**
   * Matches `url` against the installed routes and returns the first match.
   */
  _getRoute(pathname) {
    const matchedRoute = this.routes.find((r) => getPattern(r).test({ pathname }));
    if (matchedRoute || this.fallback === void 0) {
      return matchedRoute;
    }
    if (this.fallback) {
      return { ...this.fallback, path: "/*" };
    }
    return void 0;
  }
  hostConnected() {
    this._host.addEventListener(RoutesConnectedEvent.eventName, this._onRoutesConnected);
    const event = new RoutesConnectedEvent(this);
    this._host.dispatchEvent(event);
    this._onDisconnect = event.onDisconnect;
  }
  hostDisconnected() {
    var _a;
    (_a = this._onDisconnect) == null ? void 0 : _a.call(this);
    this._parentRoutes = void 0;
  }
};
var getTailGroup = (groups) => {
  let tailKey;
  for (const key of Object.keys(groups)) {
    if (/\d+/.test(key) && (tailKey === void 0 || key > tailKey)) {
      tailKey = key;
    }
  }
  return tailKey && groups[tailKey];
};
var RoutesConnectedEvent = class _RoutesConnectedEvent extends Event {
  constructor(routes) {
    super(_RoutesConnectedEvent.eventName, {
      bubbles: true,
      composed: true,
      cancelable: false
    });
    this.routes = routes;
  }
};
RoutesConnectedEvent.eventName = "lit-routes-connected";

// node_modules/@lit-labs/router/development/router.js
var origin = location.origin || location.protocol + "//" + location.host;
var Router = class extends Routes {
  constructor() {
    super(...arguments);
    this._onClick = (e) => {
      const isNonNavigationClick = e.button !== 0 || e.metaKey || e.ctrlKey || e.shiftKey;
      if (e.defaultPrevented || isNonNavigationClick) {
        return;
      }
      const anchor = e.composedPath().find((n) => n.tagName === "A");
      if (anchor === void 0 || anchor.target !== "" || anchor.hasAttribute("download") || anchor.getAttribute("rel") === "external") {
        return;
      }
      const href = anchor.href;
      if (href === "" || href.startsWith("mailto:")) {
        return;
      }
      const location2 = window.location;
      if (anchor.origin !== origin) {
        return;
      }
      e.preventDefault();
      if (href !== location2.href) {
        window.history.pushState({}, "", href);
        this.goto(anchor.pathname);
      }
    };
    this._onPopState = (_e) => {
      this.goto(window.location.pathname);
    };
  }
  hostConnected() {
    super.hostConnected();
    window.addEventListener("click", this._onClick);
    window.addEventListener("popstate", this._onPopState);
    this.goto(window.location.pathname);
  }
  hostDisconnected() {
    super.hostDisconnected();
    window.removeEventListener("click", this._onClick);
    window.removeEventListener("popstate", this._onPopState);
  }
};
export {
  Router,
  Routes,
  RoutesConnectedEvent
};
/*! Bundled license information:

@lit-labs/router/development/routes.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/router/development/router.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)

@lit-labs/router/development/index.js:
  (**
   * @license
   * Copyright 2021 Google LLC
   * SPDX-License-Identifier: BSD-3-Clause
   *)
*/
//# sourceMappingURL=@lit-labs_router.js.map
